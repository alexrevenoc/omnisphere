<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Quantum Black Hole - Final</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #000;
        font-family: sans-serif;
        cursor: none; /* Hide default cursor */
      }
      canvas {
        display: block;
      }
      #ui {
        position: absolute;
        bottom: 20px;
        left: 20px;
        color: rgba(255, 255, 255, 0.5);
        pointer-events: none;
        user-select: none;
        z-index: 10;
      }
      /* Visual Cursor */
      #bh-cursor {
        position: absolute;
        width: 40px;
        height: 40px;
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 50%;
        transform: translate(-50%, -50%);
        pointer-events: none;
        box-shadow: 0 0 30px rgba(0, 0, 0, 1), inset 0 0 20px rgba(0, 0, 0, 1);
        background: rgba(0, 0, 0, 0.3); /* Slight dark tint */
        z-index: 100;
        transition: width 0.1s, height 0.1s;
      }
      #bh-cursor.active {
        width: 60px;
        height: 60px;
        border-color: rgba(50, 50, 50, 0.5);
      }
    </style>
  </head>
  <body>
    <div id="bh-cursor"></div>
    <div id="ui">Hover to Activate Black Hole â€¢ Scroll to Zoom</div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
      import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
      import { ShaderPass } from "three/addons/postprocessing/ShaderPass.js";
      import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";

      // --- CURSOR ---
      const cursorEl = document.getElementById("bh-cursor");
      document.addEventListener("mousemove", (e) => {
        cursorEl.style.left = e.clientX + "px";
        cursorEl.style.top = e.clientY + "px";
        cursorEl.classList.add("active");
      });
      document.addEventListener("mouseleave", () => {
        cursorEl.classList.remove("active");
      });

      // --- SCENE ---
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.01,
        100
      );
      camera.position.set(0, 0.5, 4);

      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.toneMapping = THREE.ReinhardToneMapping;
      document.body.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.enablePan = false;
      controls.minDistance = 0.1;
      controls.maxDistance = 15;

      // --- RAYCASTER ---
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2(999, 999);
      const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
      const target3D = new THREE.Vector3(999, 999, 999);

      // --- PARTICLES ---
      const particlesCount = 7000;
      const geometry = new THREE.BufferGeometry();

      const positions = new Float32Array(particlesCount * 3);
      const originalPos = new Float32Array(particlesCount * 3);
      const randomness = new Float32Array(particlesCount * 3);

      for (let i = 0; i < particlesCount; i++) {
        const i3 = i * 3;
        const r = 1.8 * Math.cbrt(Math.random());
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);

        const x = r * Math.sin(phi) * Math.cos(theta);
        const y = r * Math.sin(phi) * Math.sin(theta);
        const z = r * Math.cos(phi);

        positions[i3] = x;
        positions[i3 + 1] = y;
        positions[i3 + 2] = z;
        originalPos[i3] = x;
        originalPos[i3 + 1] = y;
        originalPos[i3 + 2] = z;
        randomness[i3] = Math.random();
        randomness[i3 + 1] = Math.random();
        randomness[i3 + 2] = Math.random();
      }

      geometry.setAttribute(
        "position",
        new THREE.BufferAttribute(positions, 3)
      );
      geometry.setAttribute(
        "aOriginalPos",
        new THREE.BufferAttribute(originalPos, 3)
      );
      geometry.setAttribute(
        "aRandom",
        new THREE.BufferAttribute(randomness, 3)
      );

      // --- SHADERS ---

      const vertexShader = `
            uniform float uTime;
            uniform vec3 uBlackHolePos;
            uniform float uMouseActive;

            // NOTE: 'attribute vec3 position' is added AUTOMATICALLY by Three.js
            // We do NOT declare it here to avoid crashes.
            
            attribute vec3 aOriginalPos;
            attribute vec3 aRandom;
            
            varying vec3 vPosition;
            varying float vDistance;
            varying float vBHInfluence;

            void main() {
                vec3 newPos = aOriginalPos;
                float time = uTime * 1.0;

                // Fluid Motion
                newPos.x += sin(time * aRandom.x + newPos.y * 1.5) * 0.04;
                newPos.y += cos(time * aRandom.y + newPos.z * 1.5) * 0.04;
                newPos.z += sin(time * aRandom.z + newPos.x * 1.5) * 0.04;

                // Black Hole Logic
                float dist = distance(newPos, uBlackHolePos);
                float radius = 1.8; 
                
                vBHInfluence = 0.0;

                if(uMouseActive > 0.5 && dist < radius) {
                    float influence = 1.0 - (dist / radius);
                    influence = pow(influence, 2.0); // Power curve
                    vBHInfluence = influence;

                    vec3 dir = normalize(uBlackHolePos - newPos);
                    
                    // Strong Pull
                    newPos += dir * influence * 1.2; 

                    // Swirl
                    vec3 axis = vec3(0.0, 1.0, 0.0);
                    vec3 tangent = cross(dir, axis);
                    newPos += tangent * influence * 0.4;
                }

                vec4 mvPosition = modelViewMatrix * vec4(newPos, 1.0);
                gl_Position = projectionMatrix * mvPosition;
                
                vPosition = newPos;
                vDistance = length(newPos);
                
                // Size
                gl_PointSize = (25.0 / -mvPosition.z);
            }
        `;

      const fragmentNormal = `
            varying vec3 vPosition;
            varying float vDistance;
            varying float vBHInfluence;

            void main() {
                float strength = distance(gl_PointCoord, vec2(0.5));
                if(strength > 0.5) discard;

                // Colors
                vec3 cCore = vec3(1.0, 0.9, 0.5);
                vec3 cMid = vec3(0.8, 0.1, 0.6);
                vec3 cPole = vec3(0.0, 0.1, 0.5);

                vec3 finalColor = mix(cMid, cPole, smoothstep(0.5, 1.5, abs(vPosition.y)));
                float coreF = 1.0 - smoothstep(0.0, 1.2, vDistance);
                finalColor = mix(finalColor, cCore, coreF);

                // --- PITCH BLACK ABSORPTION ---
                // If influence is high, color becomes 0.0 (Black)
                // We use smoothstep for a slightly soft edge, but very dark
                float blackHoleFactor = smoothstep(0.0, 0.4, vBHInfluence);
                
                finalColor = mix(finalColor, vec3(0.0), blackHoleFactor); // Mix towards black

                float alpha = (0.5 - strength) * 2.0;
                
                // If fully absorbed, alpha goes to 0
                alpha *= (1.0 - blackHoleFactor);

                gl_FragColor = vec4(finalColor, alpha);
            }
        `;

      const fragmentBloom = `
            varying vec3 vPosition;
            varying float vDistance;
            varying float vBHInfluence;

            void main() {
                float strength = distance(gl_PointCoord, vec2(0.5));
                if(strength > 0.5) discard;

                vec3 bloomColor = vec3(8.0, 3.0, 1.0);
                float coreF = 1.0 - smoothstep(0.0, 0.8, vDistance);

                if(coreF < 0.05) discard;
                
                // Black Hole eats bloom aggressively
                if(vBHInfluence > 0.1) discard;

                gl_FragColor = vec4(bloomColor, (0.5 - strength) * coreF);
            }
        `;

      const uniforms = {
        uTime: { value: 0 },
        uBlackHolePos: { value: new THREE.Vector3(999, 999, 999) },
        uMouseActive: { value: 0.0 },
      };

      const materialNormal = new THREE.ShaderMaterial({
        vertexShader,
        fragmentShader: fragmentNormal,
        uniforms,
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
      });

      const materialBloom = new THREE.ShaderMaterial({
        vertexShader,
        fragmentShader: fragmentBloom,
        uniforms,
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
      });

      const particles = new THREE.Points(geometry, materialNormal);
      scene.add(particles);

      // --- COMPOSER ---
      const renderTarget = new THREE.WebGLRenderTarget(
        window.innerWidth,
        window.innerHeight,
        {
          minFilter: THREE.LinearFilter,
          magFilter: THREE.LinearFilter,
          format: THREE.RGBAFormat,
        }
      );

      const bloomComposer = new EffectComposer(renderer, renderTarget);
      bloomComposer.renderToScreen = false;
      bloomComposer.addPass(new RenderPass(scene, camera));

      const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        1.5,
        0.4,
        0.85
      );
      bloomPass.threshold = 0;
      bloomPass.strength = 2.5;
      bloomPass.radius = 0.5;
      bloomComposer.addPass(bloomPass);

      const finalComposer = new EffectComposer(renderer);
      finalComposer.addPass(new RenderPass(scene, camera));

      const mixPass = new ShaderPass(
        new THREE.ShaderMaterial({
          uniforms: {
            baseTexture: { value: null },
            bloomTexture: { value: renderTarget.texture },
          },
          vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
          fragmentShader: `
                    uniform sampler2D baseTexture; uniform sampler2D bloomTexture; varying vec2 vUv;
                    void main() {
                        vec4 base = texture2D(baseTexture, vUv);
                        vec4 bloom = texture2D(bloomTexture, vUv);
                        gl_FragColor = base + bloom; 
                    }
                `,
        }),
        "baseTexture"
      );
      finalComposer.addPass(mixPass);

      // --- EVENTS ---
      document.addEventListener("mousemove", (e) => {
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        raycaster.ray.intersectPlane(plane, target3D);
        uniforms.uBlackHolePos.value.copy(target3D);
        uniforms.uMouseActive.value = 1.0;
      });
      document.addEventListener("mouseleave", () => {
        uniforms.uMouseActive.value = 0.0;
        uniforms.uBlackHolePos.value.set(999, 999, 999);
      });
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        bloomComposer.setSize(window.innerWidth, window.innerHeight);
        finalComposer.setSize(window.innerWidth, window.innerHeight);
      });

      // --- ANIMATION ---
      const clock = new THREE.Clock();
      function animate() {
        requestAnimationFrame(animate);
        const elapsed = clock.getElapsedTime();
        uniforms.uTime.value = elapsed;
        controls.update();
        particles.rotation.y = elapsed * 0.05;

        particles.material = materialBloom;
        bloomComposer.render();

        particles.material = materialNormal;
        finalComposer.render();
      }
      animate();
    </script>
  </body>
</html>
